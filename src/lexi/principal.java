/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package lexi;

import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.io.File;
import javax.swing.JFileChooser;
import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.DefaultListModel;

/**
 *
 * @author Aishisu
 */
public class principal extends javax.swing.JFrame {
    DefaultListModel codigo = new DefaultListModel();
    DefaultListModel codigo3 = new DefaultListModel();
    /**
     * Creates new form principal
     */
    
    public principal() {
        initComponents();
        codigo = new DefaultListModel();
        codigo3 = new DefaultListModel();
        showcod.setModel(codigo);
        showerror.setModel(codigo3);
        this.setLocationRelativeTo(null);
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jPanel1 = new javax.swing.JPanel();
        start = new javax.swing.JButton();
        jScrollPane6 = new javax.swing.JScrollPane();
        showerror = new javax.swing.JList<>();
        jScrollPane5 = new javax.swing.JScrollPane();
        showcod = new javax.swing.JList<>();
        jPanel2 = new javax.swing.JPanel();
        jLabel1 = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        start.setBackground(new java.awt.Color(0, 0, 51));
        start.setFont(new java.awt.Font("Consolas", 0, 12)); // NOI18N
        start.setForeground(new java.awt.Color(78, 161, 87));
        start.setText("Buscar y analizar");
        start.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                startActionPerformed(evt);
            }
        });

        showerror.setFont(new java.awt.Font("Consolas", 0, 12)); // NOI18N
        jScrollPane6.setViewportView(showerror);

        showcod.setFont(new java.awt.Font("Consolas", 0, 12)); // NOI18N
        showcod.setForeground(new java.awt.Color(78, 161, 87));
        jScrollPane5.setViewportView(showcod);

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addGap(17, 17, 17)
                        .addComponent(start)
                        .addGap(26, 26, 26)
                        .addComponent(jScrollPane5, javax.swing.GroupLayout.PREFERRED_SIZE, 648, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(0, 0, Short.MAX_VALUE))
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(jScrollPane6)))
                .addContainerGap())
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(jScrollPane5, javax.swing.GroupLayout.PREFERRED_SIZE, 361, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addGap(146, 146, 146)
                        .addComponent(start, javax.swing.GroupLayout.PREFERRED_SIZE, 64, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 12, Short.MAX_VALUE)
                .addComponent(jScrollPane6, javax.swing.GroupLayout.PREFERRED_SIZE, 181, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
        );

        jPanel2.setBackground(new java.awt.Color(0, 0, 51));

        jLabel1.setFont(new java.awt.Font("Consolas", 1, 18)); // NOI18N
        jLabel1.setForeground(new java.awt.Color(78, 161, 87));
        jLabel1.setText("iTZRAMN");

        javax.swing.GroupLayout jPanel2Layout = new javax.swing.GroupLayout(jPanel2);
        jPanel2.setLayout(jPanel2Layout);
        jPanel2Layout.setHorizontalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel2Layout.createSequentialGroup()
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(jLabel1)
                .addGap(378, 378, 378))
        );
        jPanel2Layout.setVerticalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel2Layout.createSequentialGroup()
                .addContainerGap(10, Short.MAX_VALUE)
                .addComponent(jLabel1)
                .addContainerGap())
        );

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
            .addComponent(jPanel2, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addComponent(jPanel2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void startActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_startActionPerformed
        //Lee archivo txt
        String rutap = new File ("").getAbsolutePath ()+"/";
        JFileChooser chooser = new JFileChooser(new File(rutap));
        chooser.showOpenDialog(null);
        File archivo = new File(chooser.getSelectedFile().getAbsolutePath());

        String linea;

        try
        {
            FileReader f = new FileReader(archivo);
            BufferedReader b = new BufferedReader(f);

            //Lee linea a linea el archivo txt
            int cont = 1;
            while((linea = b.readLine())!= null)
            {
                codigo.addElement(linea);
                if (verificaLinea(linea,cont))
                {
                    System.out.println("Syntaxis error "+linea+" linea "+cont);
                    codigo3.addElement("Syntaxis error '"+linea+"' linea "+cont);
                }
                //Pasa a la siguiente linea
                cont++;
            }
            structureVerify();
        } catch (FileNotFoundException ex) {
            Logger.getLogger(principal.class.getName()).log(Level.SEVERE, null, ex);
        } catch (IOException ex) {
            Logger.getLogger(principal.class.getName()).log(Level.SEVERE, null, ex);
        }
        //Termina leer archivo txt y todo el programa
    }//GEN-LAST:event_startActionPerformed

//Expresiones regulares para detectar inicio o fin en zonas
String[] BodiesEx = 
{
    "\\s*Comienzo\\s*"          //Case 1
    ,"\\s*Final\\s*"            //Case 2
    ,"\\s*Inicio_cuerpo\\s*"    //Case 3
    ,"\\s*Fin_cuerpo\\s*"       //Case 4
    ,"\\s*Clases_inicio\\s*"    //Case 5
    ,"\\s*Clases_fin\\s*"       //Case 6
    ,"\\s*Variablezona\\s*"     //Case 7
    ,"\\s*Variablefin\\s*"      //Case 8
}; 

//Expresiones regulares para detectar declaracion de variables
String[] DeclarationEx = 
{
    "\\s*Cadena\\s+[A-Za-z-_]*([A-Za-z-_]|[0-9]*)+\\s*(=+\\s*(.{1,45})\\s*\\?|\\s*\\?)$"
    ,"\\s*Entero\\s+[A-Za-z-_]*([A-Za-z-_]|[0-9]*)+\\s*(=\\s*([0-9]{1,8})\\s*\\?|\\s*\\?)$"
    ,"\\s*Decimal\\s+[A-Za-z-_]*([A-Za-z-_]|[0-9]*)+\\s*(=\\s*([0-9]{1,8}|[0-9]*\\.+[0-9]{0,3})\\s*\\?|\\s*\\?)$"
    ,"\\s*Boleano\\s+[A-Za-z-_]*([A-Za-z-_]|[0-9]*)+\\s*(=+\\s*(V|F)\\s*\\?|\\s*\\?)$"
    ,"\\s*"
};

//Expresiones regulares para detectar inicio o fin de estructuras de control
String[] StructursEx = 
{
    "\\s*Si\\s*\\(\\s*[A-Za-z-_]*([A-Za-z-_]|[0-9]+)+\\s*(<|<=|>|>=|==|=|<>)\\s*[A-Za-z-_]*([A-Za-z-_]|[0-9]+)\\s*(\\s*(&&|\\|\\||)\\s*[A-Za-z-_]*([A-Za-z-_]|[0-9]+)\\s*(<|<=|>|>=|==|=|<>)\\s*[A-Za-z-_]*([A-Za-z-_]|[0-9]+)\\s*)*\\)",
    "\\s*Otro",
    "\\s*Fin_si",
    "\\s*Hacer",
    "\\s*Mientras\\s*\\(\\s*[A-Za-z-_]*([A-Za-z-_]|[0-9]+)+\\s*(<|<=|>|>=|==|=|<>)\\s*[A-Za-z-_]*([A-Za-z-_]|[0-9]+)\\s*(\\s*(&&|\\|\\||)\\s*[A-Za-z-_]*([A-Za-z-_]|[0-9]+)\\s*(<|<=|>|>=|==|=|<>)\\s*[A-Za-z-_]*([A-Za-z-_]|[0-9]+)\\s*)*\\)+\\s*\\?",
    "\\s*Mientras\\s*\\(\\s*[A-Za-z-_]*([A-Za-z-_]|[0-9]+)+\\s*(<|<=|>|>=|==|=|<>)\\s*[A-Za-z-_]*([A-Za-z-_]|[0-9]+)\\s*(\\s*(&&|\\|\\||)\\s*[A-Za-z-_]*([A-Za-z-_]|[0-9]+)\\s*(<|<=|>|>=|==|=|<>)\\s*[A-Za-z-_]*([A-Za-z-_]|[0-9]+)\\s*)*\\)",
    "\\s*Fin_mientras",
    "\\s*"
};

//Lista de caracteres no permitidos, si se encuentra uno de estos se considera como error
String noCharters = "ñ|°|;|";

String operations = "\\s*[A-Za-z-_]+([A-Za-z-_]|[0-9]*)+\\s*\\=\\s*([A-Za-z-_]+([A-Za-z-_]|[0-9]*)|[0-9])\\s*((\\+|\\-|\\*|\\/)\\s*([A-Za-z-_]+([A-Za-z-_]|[0-9]*)|[0-9]*\\s*)\\s*)*\\?";
    
//Expresiones regulares para detectar casos expesificos
String[] expresiones = 
{
    "\\s*\\#Clase+[0-9]{1,}"
    ,"\\s*Leer\\s+([A-Za-z-_]*([A-Za-z-_]|[0-9]*)+\\s*\\?|(\\,?[A-Za-z-_]*([A-Za-z-_]|[0-9]))*\\s*\\?)"
    ,"\\s*Imprimir\\s+((\\\".*\\\"\\s*\\?)|([A-Za-z-_]*([A-Za-z-_]|[0-9]*\\?))|(\\\"[A-Za-z-_]*([A-Za-z-_]|[0-9]*)*\\\"\\s*\\,\\s*[A-Za-z-_]*([A-Za-z-_]|[0-9])*\\?))"
    ,"/\\t/g" //tabs
    ,"/ /g" //espacios
    ,"//[^\r\n]*" //comentarios
    ,"\\r\\n" //salto de linea
    ,"\\s*"
};

    //Declaramos listas para almacenar las diferentes variables que encontremos    
    List varsEnt = new ArrayList(); //Variables enteras
    List varsCad = new ArrayList(); //Variables cadena
    List varsDec = new ArrayList(); //variables decimal
    List varsBol = new ArrayList(); //Variables boolean
    List ErrorsF = new ArrayList(); //Mensajes de posibles errores
    List flagFou = new ArrayList(); //Linea en la que se abre o cierra una estructura
                                    //Este arreglo debe quedar vacio al final
    
    //Banderas y sus respectivos contadores
    //Al final los contadores deben tener un valor de 0
    boolean start_pr = false;   //Inicio de programa
    boolean end_pr = false;     // Fin de programa
    int prZone = 0;            //Contador program
    
    boolean start_vr = false;   //Inicio zona de declaracion de variables
    boolean end_vr = false;     //Fin zon de declaracion de variables
    int vrZone = 0;                //Contador zona de variables
    
    boolean start_bd = false;   //Inicio body
    boolean end_bd = false;     //Fin body
    int bdZone = 0;                //Contador body
    
    boolean start_cl = false;   //Inicio clase
    boolean end_cl = false;     //Fin clase
    int clZone = 0;                //Contador clases
    
    boolean start_if = false;   //Inicio estructura if
    boolean start_ot = false;
    boolean end_if = false;     //Fin estructura if
    int ifstruct = 0;                //Contador if
    
    boolean start_dw = false;   //Inicio estructura do while
    boolean end_dw = false;     //Fin estructura do whhile
    int dwstruct = 0;                //Contador do while
    
    boolean start_wh = false;   //Inicio estructura while
    boolean end_wh = false;     //Fin estructura while
    int whstruct = 0;                //Contador while
    
    //Levanta las banderas necesarias segun el caso
    private void flipFlagBodies(int pos,int linePos)
    {
        switch (pos)
        {
            case 1:
                System.out.println("Inicio de programa encontrado");
                start_pr = true;
                prZone++;
                //ErrorsF.add("Programa inicia pero nunca cierra, linea "+linePos);
                flagFou.add(linePos);
                break;
            case 2: 
                System.out.println("Fin de programa encontrado");
                end_pr = true;
                prZone--;
                if (flagFou.size()>0) 
                {
                    flagFou.remove(flagFou.size()-1);
                }
                break;
            case 3:
                System.out.println("Inicio de body encontrado");
                start_bd = true;
                bdZone++;
                flagFou.add(linePos);
                break;
            case 4:
                System.out.println("Fin de body encontrado");
                end_bd = true;
                bdZone--;
                if (flagFou.size()>0) 
                {
                    flagFou.remove(flagFou.size()-1);
                }
                break;
            case 5:
                System.out.println("Inicio de clase encontrado");
                start_cl = true;
                clZone++;
                flagFou.add(linePos);
                break;
            case 6: 
                System.out.println("Fin de clase encontrado");
                end_cl = true;
                clZone--;
                if (flagFou.size()>0) 
                {
                    flagFou.remove(flagFou.size()-1);
                }
                break;
            case 7:
                System.out.println("Inicio de zona de variables encontrado");
                start_vr = true;
                vrZone++;
                flagFou.add(linePos);
                break;
            case 8:
                System.out.println("Fin de zona de variables encontrado");
                end_vr = true;
                vrZone--;
                if (flagFou.size()>0) 
                {
                    flagFou.remove(flagFou.size()-1);
                }
                break;
        }
    }
    
    private void flipFlagStructs(int pos, int linePos)
    {
        switch (pos)
        {
            case 1:
                System.out.println("Inicio de if encontrado");
                start_if = true;
                ifstruct++;
                flagFou.add(linePos);
                break;
            case 2:
                System.out.println("Else(Otro) encontrado");
                start_ot = true;
                ifstruct--;
                flagFou.add(linePos);
                break;
            case 3: 
                System.out.println("Fin de if encontrado");
                end_if = true;
                ifstruct--;
                if (flagFou.size()>0) 
                {
                    flagFou.remove(flagFou.size()-1);
                }
                break;
            case 4:
                System.out.println("Inicio de do while encontrado");
                start_dw = true;
                dwstruct++;
                flagFou.add(linePos);
                break;
            case 5:
                System.out.println("Fin de do while encontrado");
                end_dw = true;
                dwstruct--;
                if (flagFou.size()>0) 
                {
                    flagFou.remove(flagFou.size()-1);
                }
                break;
            case 6:
                System.out.println("Inicio de while encontrado");
                start_wh = true;
                whstruct++;
                flagFou.add(linePos);
                break;
            case 7:
                System.out.println("Fin de while encontrado");
                end_wh = true;
                whstruct--;
                if (flagFou.size()>0) 
                {
                    flagFou.remove(flagFou.size()-1);
                }
                break;
        }
    }
    
    private void setVar(int pos, String line)
    {
        switch (pos)
        {
            case 1: //Cadena
                System.out.print("Declaracion de cadena encontrado ");
                varsCad.add(getVar(line,"Cadena"));
                break;
            case 2: //Entero
                System.out.print("Declaracion de entero encontrado ");
                varsEnt.add(getVar(line,"Entero"));
                break;
            case 3: //Decimal
                System.out.print("Declaracion de decimal encontrado ");
                varsDec.add(getVar(line,"Decimal"));
                break;
            case 4: //Boleano
                System.out.print("Declaracion de boleano encontrado ");
                varsBol.add(getVar(line,"Boleano"));
                break;
        }
    }
    
    private String getVar(String line,String typeData)
    {
        String varName = null;
        
        String[] data = line.split("\\s");
        
        for (int i = 0; i < data.length; i++) 
        {
            //Segun la regla de declaracion de variables enseguida del tipo de dato
            //Debe existir uno o mas espacios pero la siguiente cadena se considera como la variable
            if (data[i].toUpperCase().contains(typeData.toUpperCase())) 
            {
                //En caso de que la asignacion este junto a la variable se divide nuevamente
                String[] aux = data[i+1].split("=|\\?");
                //Solo se toma el primer valor del array
                varName = aux[0];
                
                System.out.println("el nombre de la variable es: "+varName);
            }
        }
        
        return varName;
    }
    
    //Verifica que la linea cumpla con almenos una regla establecida, 
    //en caso de no cumplir con alguna se establece como error
    public boolean verificaLinea(String linea,int linePos)
    {   
        boolean error = true;
        
        //Verificamos que no exista ningun caracter no permitido en la linea
        Pattern p1 = Pattern.compile(noCharters);
        Matcher matcher1 = p1.matcher(linea); 
        if (matcher1.matches()) 
        {
            System.out.println("Se encontro un caracter no permitido");
            return error;
        }
        
        //Verificamos la linea contra una estructura base
        for (int i = 0; i <BodiesEx.length; i++)
        {
            Pattern p = Pattern.compile(BodiesEx[i]);
            Matcher matcher = p.matcher(linea); 
            if (matcher.matches()) 
            {
                //Levantamos la bandera segun el inicio o fin del cuerpo encontrado
                flipFlagBodies(i+1,linePos);
                //Terminamos la revision de esta linea
                error = false;
                return error;
            }   
        }
        
        //Verificamos la linea contra una estructura de control
        for (int i = 0; i <StructursEx.length; i++) 
        {
            Pattern p = Pattern.compile(StructursEx[i]);
            Matcher matcher = p.matcher(linea); 
            if (matcher.matches()) 
            {
                //Levantamos la bandera segun el inicio o fin del cuerpo encontrado
                flipFlagStructs(i+1,linePos);
                //Terminamos la revision de esta linea
                error = false;
                return error;
            }   
        }
        
        //Verificamos la linea contra declaraciones
        for (int i = 0; i <DeclarationEx.length; i++) 
        {
            Pattern p = Pattern.compile(DeclarationEx[i]);
            Matcher matcher = p.matcher(linea); 
            if (matcher.matches()) 
            {
                //Buscamos la variable en la declaracion
                setVar(i+1,linea);
                //Terminamos la revision de esta linea
                error = false;
                return error;
            }   
        }
        
        //Verificamos la linea contra expresiones generales
        for (int i = 0; i <expresiones.length; i++) 
        {
            Pattern p = Pattern.compile(expresiones[i]);
            Matcher matcher = p.matcher(linea); 
            if (matcher.matches()) 
            {
                //Validacion pendiente
                //setVar(i+1,linea);
                //Terminamos la revision de esta linea
                error = false;
                return error;
            }   
        }
        
        Pattern p2 = Pattern.compile(operations);
        Matcher matcher2 = p2.matcher(linea); 
        if (matcher2.matches()) 
        {
            System.out.println("Se encontro una operacion aritmetica");
            error = checkOperation(linea);
            return error;
        }
        
        return error;
    }
    
    private boolean checkOperation(String line)
    {
        boolean error = false;
        
        List<Integer> vars = getVarOperation(line);
        
        for(Integer varCheck: vars)
        {
            if(!varCheck.equals(vars.get(0)))
            {
                error = true;
                return error;
            }
        }
        
        return error;
    }
    
    private List<Integer> getVarOperation(String linea)
    {
        String[] auxEx = 
        {
            "\\d{1,9}" //Es un entero
            ,"\\d{1,9}\\.\\d{1,4}" //Es un decimal
            ,"\\w+"//Es una variable
        };
        List<Integer> varsOperation = new ArrayList();
        
        System.out.println(linea);
        
        String[] split1 = linea.split("\\s|\\+|\\-|\\=|\\/|\\*|\\?");
        
        for (int i = 0; i < split1.length; i++) 
        {
            checkPoint:
            
            for (int j = 0; j < auxEx.length; j++) 
            {
                Pattern p = Pattern.compile(auxEx[j]);
                Matcher matcher = p.matcher(split1[i]); 
                if (matcher.matches()) 
                {
                    switch (j)
                    {
                        case 0:
                            System.out.println("Se encontro un entero");
                            varsOperation.add(2);
                            break checkPoint;
                        case 1:
                            System.out.println("Se encontro un decimal");
                            varsOperation.add(3);
                            break checkPoint;
                        case 2:
                            System.out.println("Se encontro una variable");
                            varsOperation.add(existVar(split1[i]));
                            break checkPoint;
                    }
                }
            }
        }
        
        return varsOperation;
    }
    
    //Si existe regresa uno de los siguientes valores
    // 1 Cadena
    // 2 Enteros
    // 3 Decimales
    // 4 Booleanos
    private int existVar(String var)
    {
        int valueVar = 0;
        
        if (varsCad.contains(var)) 
        {
            //La variable es una cadena
            valueVar = 1;
            return valueVar;
        }
        if (varsEnt.contains(var)) 
        {
            //La variable es un entero
            valueVar = 2;
            return valueVar;
        }
        if (varsDec.contains(var)) 
        {
            //La variable es un decimal
            valueVar = 3;
            return valueVar;
        }
        if (varsBol.contains(var)) 
        {
            //La variable es un boleano
            valueVar = 4;
            return valueVar;
        }
        
        return valueVar;
    }
    
    private void structureVerify()
    {
        //Verifica errores en el inicio y fin de programa
        if (prZone!=0) 
        {
            System.out.print("Error con la declaracion del programa, ");
            if (!start_pr) 
            {
                System.out.print("Inicio de programa no encontrado ");
                codigo3.addElement("Inicio de programa no encontrado");
            }
            if (!end_pr) 
            {
                System.out.print("Fin de programa no encontrado ");
                codigo3.addElement("Fin de programa no encontrado");
            }
            if (start_pr==true && end_pr==false) 
            {
                System.out.print("Programa inicia pero nunca termina ");
                codigo3.addElement("Programa inicia pero nunca termina");
            }
            if (start_pr==false && end_pr==true) 
            {
                System.out.print("Programa nunca inicia ");
                codigo3.addElement("Programa nunca inicia");
            }
            System.out.println();
        }
        
        //Verifica errores en el inicio y fin de variables
        if (vrZone!=0) 
        {
            System.out.print("Error con la declaracion de la zona de variables, ");
            if (!start_vr) 
            {
                System.out.print("Inicio de zona de variables no encontrado ");
                codigo3.addElement("Inicio de zona de variables no encontrado");
            }
            if (!end_vr) 
            {
                System.out.print("Fin de zona de variables no encontrado ");
                codigo3.addElement("Fin de zona de variables no encontrado");
            }
            if (start_vr==true && end_vr==false) 
            {
                System.out.print("Zona de variables inicia pero nunca termina ");
                codigo3.addElement("Zona de variables inicia pero nunca termina");
            }
            if (start_vr==false && end_vr==true) 
            {
                System.out.print("Zona de variables nunca inicia ");
                codigo3.addElement("Zona de variables nunca inicia");
            }
            System.out.println();
        }
        
        //Verifica errores en el inicio y fin del body
        if (bdZone!=0) 
        {
            System.out.print("Error con la declaracion del body, ");
            if (!start_bd) 
            {
                System.out.print("Inicio del body no encontrado ");
                codigo3.addElement("Inicio del body no encontrado");
            }
            if (!end_bd) 
            {
                System.out.print("Fin del body no encontrado ");
                codigo3.addElement("Fin del body no encontrado");
            }
            if (start_bd==true && end_bd==false) 
            {
                System.out.print("Body inicia pero nunca termina ");
                codigo3.addElement("Body inicia pero nunca termina");
            }
            if (start_bd==false && end_bd==true) 
            {
                System.out.print("Body nunca inicia ");
                codigo3.addElement("Body nunca inicia");
            }
            System.out.println();
        }
        
        //Verifica errores en el inicio y fin de las clases
        if (clZone!=0) 
        {
            System.out.print("Error con la declaracion de la clase, ");
            if (!start_cl) 
            {
                System.out.print("Inicio de la clase no encontrado ");
                codigo3.addElement("Inicio de la clase no encontrado");
            }
            if (!end_cl) 
            {
                System.out.print("Fin de la clase no encontrado ");
                codigo3.addElement("Fin de la clase no encontrado");
            }
            if (start_cl==true && end_cl==false) 
            {
                System.out.print("La clase inicia pero nunca termina ");
                codigo3.addElement("La clase inicia pero nunca termina");
            }
            if (start_cl==false && end_cl==true) 
            {
                System.out.print("La clase nunca inicia ");
                codigo3.addElement("La clase nunca inicia");
            }
            System.out.println();
        }
        
        //Verifica errores en el inicio y fin del if
        if (ifstruct!=0) 
        {
            System.out.print("Error con la estructura if, ");
            if (!start_if) 
            {
                System.out.print("Inicio del if no encontrado ");
                codigo3.addElement("Inicio del if no encontrado");
            }
//            if (!start_ot) 
//            {
//                System.out.print("Other no encontrado ");
//                codigo3.addElement("Other no encontrado");
//            }
            if (!end_if) 
            {
                System.out.print("Fin del if no encontrado ");
                codigo3.addElement("Fin del if no encontrado");
            }
            if (start_if==true && end_if==false) 
            {
                System.out.print("If inicia pero nunca termina ");
                codigo3.addElement("If inicia pero nunca termina");
            }
            if (start_if==false && end_if==true) 
            {
                System.out.print("If nunca inicia ");
                codigo3.addElement("If nunca inicia");
            }
            if(start_ot==true && start_if==false)
            {
                System.out.print("Other necesita iniciar if ");
                codigo3.addElement("Other necesita iniciar if");
            }
            System.out.println();
        }
        
        //Verifica errores en el inicio y fin del do while
        if (dwstruct!=0) 
        {
            System.out.print("Error con la estructura do while, ");
            if (!start_dw) 
            {
                System.out.print("Inicio del do while no encontrado ");
                codigo3.addElement("Inicio del do while no encontrado");
            }
            if (!end_dw) 
            {
                System.out.print("Fin del do while no encontrado ");
                codigo3.addElement("Fin del do while no encontrado");
            }
            if (start_dw==true && end_dw==false) 
            {
                System.out.print("Do while inicia pero nunca termina ");
                codigo3.addElement("Do while inicia pero nunca termina");
            }
            if (start_dw==false && end_dw==true) 
            {
                System.out.print("Do while nunca inicia ");
                codigo3.addElement("Do while nunca inicia");
            }
            System.out.println();
        }
        
        //Verifica errores en el inicio y fin del while
        if (whstruct!=0) 
        {
            System.out.print("Error con la estructura while, ");
            if (!start_wh) 
            {
                System.out.print("Inicio del while no encontrado ");
                codigo3.addElement("Inicio del while no encontrado");
            }
            if (!end_wh) 
            {
                System.out.print("Fin del while no encontrado ");
                codigo3.addElement("Fin del while no encontrado");
            }
            if (start_wh==true && end_wh==false) 
            {
                System.out.print("While inicia pero nunca termina ");
                codigo3.addElement("While inicia pero nunca termina");
            }
            if (start_wh==false && end_wh==true) 
            {
                System.out.print("While nunca inicia ");
                codigo3.addElement("While nunca inicia");
            }
            System.out.println();
        }
    }
    
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(principal.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(principal.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(principal.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(principal.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(() -> {
            new principal().setVisible(true);
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JLabel jLabel1;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JPanel jPanel2;
    private javax.swing.JScrollPane jScrollPane5;
    private javax.swing.JScrollPane jScrollPane6;
    private javax.swing.JList<String> showcod;
    private javax.swing.JList<String> showerror;
    private javax.swing.JButton start;
    // End of variables declaration//GEN-END:variables
}
